{"version":3,"sources":["webpack://pixi-shadows/webpack/universalModuleDefinition","webpack://pixi-shadows/webpack/bootstrap","webpack://pixi-shadows/./src/shadows/Shadow.js","webpack://pixi-shadows/./src/shadows/filters/FilterFuncs.js","webpack://pixi-shadows/./src/shadows/filters/ShadowFilter.js","webpack://pixi-shadows/./src/shadows/filters/ShadowMapFilter.js","webpack://pixi-shadows/./src/shadows/filters/ShadowMaskFilter.js","webpack://pixi-shadows/./src/shadows/index.js","webpack://pixi-shadows/./src/shadows/mixins/Application.js","webpack://pixi-shadows/./src/shadows/mixins/Container.js"],"names":["Shadow","range","intensity","pointCount","scatterRange","PIXI","RenderTexture","create","_range","_pointCount","_scatterRange","_intensity","_radialResolution","_depthResolution","_darkenOverlay","_overlayLightLength","Infinity","anchor","set","_ignoreShadowCaster","__createShadowMapSources","texture","destroy","_shadowMapSprite","_shadowMapResultSprite","_shadowMapResultTexture","baseTexture","scaleMode","SCALE_MODES","NEAREST","Sprite","filters","ShadowMapFilter","filter","ShadowMaskFilter","blendMode","BLEND_MODES","ADD","shadowFilter","renderer","renderStep","shadowCasterSprite","shadowOverlaySprite","_shadowCasterSprite","_shadowOverlaySprite","render","__updateTextureSize","count","resolution","sprite","bool","length","filterFuncs","ShadowFilter","width","height","_width","_height","tick","uniforms","ambientLight","size","_useShadowCastersAsOverlay","__createCasterSources","__createOverlaySources","__createMaskSources","_shadowOverlayResultTexture","_shadowOverlayResultSprite","_shadowOverlayContainer","Container","_shadowCasterResultTexture","_shadowCasterResultSprite","_shadowCasterContainer","_maskResultTexture","_maskResultSprite","_maskMatrix","Matrix","_maskContainer","children","forEach","child","_activeParentLayer","overlay","shadow","update","filterManager","input","output","maskSprite","tex","valid","transform","TextureMatrix","mask","otherMatrix","calculateSpriteMatrix","applyFilter","frac","val","Filter","maxDepthResolution","lightPointCount","dimensions","radialResolution","autoFit","padding","ignoreShadowCasterMatrix","darkenOverlay","sc","shadowCasterSpriteDimensions","shadowCasterSampler","_texture","wt","worldTransform","scale","Math","sqrt","a","b","lightRange","lightScatterRange","lightLoc","tx","ty","depthResolution","isc","ignoreShadowCaster","hasIgnoreShadowCaster","copy","invert","ignoreShadowCasterDimensions","ignoreShadowCasterSampler","shadowSampler","_inverted","overlayMatrix","shadowOverlaySpriteDimensions","shadowOverlaySampler","lightIntensity","overlayLightLength","inverted","texWidth","abs","texHeight","d","c","shadows","init","application","casterGroup","display","Group","casterLayer","Layer","overlayGroup","overlayLayer","renderWebGL","container","stage","addChild","lights","diffuseLayer","diffuseGroup","normalLayer","normalGroup","lightLayer","lightGroup","diffuseBlackSprite","getRenderTexture","tint","__classes","ContainerSetup","ApplicationSetup","FilterFuncs","augment","Stage","ticker","remove","cacheParent","parent","_tempDisplayObjectParent","updateTransform","undefined","setup","shadowCasterGroup","shadowOverlayGroup","orTransform","prototype","parentGroup","push","apply","arguments"],"mappings":"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","file":"pixi-shadows.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"pixi-shadows\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"pixi-shadows\"] = factory();\n\telse\n\t\troot[\"pixi-shadows\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/shadows/index.js\");\n","import ShadowMaskFilter from \"./filters/ShadowMaskFilter\";\r\nimport ShadowMapFilter from \"./filters/ShadowMapFilter\";\r\n\r\n/**\r\n * @class\r\n * @memberof PIXI.shadows\r\n *\r\n * @param range {number} The radius of the lit area in pixels.\r\n * @param [intensity=1] {number} The opacity of the lit area.\r\n * @param [pointCount=20] {number} The number of points that makes up this light.\r\n * @param [scatterRange=15] {number} The radius at which the points of the light should be scattered.\r\n */\r\n\r\nexport default class Shadow extends PIXI.Sprite {\r\n    constructor(range, intensity, pointCount, scatterRange) {\r\n        super(PIXI.RenderTexture.create(range * 2, range * 2));\r\n\r\n        this._range = range;\r\n        this._pointCount = pointCount || 20; //The number of lightpoins\r\n        this._scatterRange = scatterRange || (this._pointCount == 1 ? 0 : 15);\r\n        this._intensity = intensity || 1;\r\n        this._radialResolution = 800;\r\n        this._depthResolution = 1; //per screen pixel\r\n        this._darkenOverlay = false;\r\n        this._overlayLightLength = Infinity;\r\n        this.anchor.set(0.5);\r\n\r\n        this._ignoreShadowCaster;\r\n\r\n        this.__createShadowMapSources();\r\n    }\r\n    // Create the texture to apply this mask filter to\r\n    __updateTextureSize() {\r\n        this.texture.destroy();\r\n        this.texture = PIXI.RenderTexture.create(\r\n            this._range * 2,\r\n            this._range * 2\r\n        );\r\n    }\r\n    // Create the resources that create the shadow map\r\n    __createShadowMapSources() {\r\n        if (this._shadowMapSprite) this._shadowMapSprite.destroy();\r\n        if (this._shadowMapResultSprite) this._shadowMapResultSprite.destroy();\r\n        if (this._shadowMapResultTexture)\r\n            this._shadowMapResultTexture.destroy();\r\n\r\n        // A blank texture/sprite to apply the filter to\r\n        this._shadowMapResultTexture = PIXI.RenderTexture.create(\r\n            this._radialResolution,\r\n            this._pointCount\r\n        );\r\n        this._shadowMapResultTexture.baseTexture.scaleMode =\r\n            PIXI.SCALE_MODES.NEAREST;\r\n        this._shadowMapSprite = new PIXI.Sprite(this._shadowMapResultTexture);\r\n        this._shadowMapSprite.filters = [new ShadowMapFilter(this)];\r\n\r\n        // The resulting texture/sprite after the filter has been applied\r\n        this._shadowMapResultSprite = new PIXI.Sprite(\r\n            this._shadowMapResultTexture\r\n        );\r\n\r\n        // Create the mask filter\r\n        var filter = new ShadowMaskFilter(this);\r\n        filter.blendMode = PIXI.BLEND_MODES.ADD;\r\n        this.shadowFilter = filter;\r\n        this.filters = [filter];\r\n    }\r\n    // Properly dispose all the created resources\r\n    destroy() {\r\n        if (this._shadowMapSprite) this._shadowMapSprite.destroy();\r\n        if (this._shadowMapResultSprite) this._shadowMapResultSprite.destroy();\r\n        if (this._shadowMapResultTexture)\r\n            this._shadowMapResultTexture.destroy();\r\n        this.texture.destroy();\r\n        return super.destroy();\r\n    }\r\n    // Don't render this sprite unless we are in the dedicated render step called by the shadow filter\r\n    renderAdvancedWebGL(renderer) {\r\n        if (this.renderStep) super.renderAdvancedWebGL(renderer);\r\n    }\r\n\r\n    // Update the map to create the mask from\r\n    update(renderer, shadowCasterSprite, shadowOverlaySprite) {\r\n        this._shadowCasterSprite = shadowCasterSprite;\r\n        this._shadowOverlaySprite = shadowOverlaySprite;\r\n        renderer.render(\r\n            this._shadowMapSprite,\r\n            this._shadowMapResultTexture,\r\n            true,\r\n            null,\r\n            true\r\n        );\r\n    }\r\n\r\n    // Attribute setters\r\n    /**\r\n     * @type {number} The radius of the lit area in pixels.\r\n     */\r\n    set range(range) {\r\n        this._range = range;\r\n        this.__updateTextureSize();\r\n    }\r\n    /**\r\n     * @type {number} The number of points that makes up this light, for soft shadows. (More points = softer shadow edges + more intensive).\r\n     */\r\n    set pointCount(count) {\r\n        this._pointCount = count;\r\n        this.__createShadowMapSources();\r\n    }\r\n    /**\r\n     * @type {number} The opacity of the lit area. (may exceed 1).\r\n     */\r\n    set scatterRange(range) {\r\n        this._scatterRange = range;\r\n    }\r\n    /**\r\n     * @type {number} The radius at which the points of the light should be scattered. (Greater range = software shadow).\r\n     */\r\n    set intensity(intensity) {\r\n        this._intensity = intensity;\r\n    }\r\n    /**\r\n     * @type {number} The number of rays to draw for the light. (Higher resolution = more precise edges + more intensive).\r\n     */\r\n    set radialResolution(resolution) {\r\n        this._radialResolution = resolution;\r\n        this.__createShadowMapSources();\r\n    }\r\n    /**\r\n     * @type {number} The of steps to take per pixel. (Higher resolution = more precise edges + more intensive).\r\n     */\r\n    set depthResolution(resolution) {\r\n        this._depthResolution = resolution;\r\n    }\r\n    /**\r\n     * @type {PIXI.Sprite} A shadow caster to ignore while creating the shadows. (Can be used if sprite and light always overlap).\r\n     */\r\n    set ignoreShadowCaster(sprite) {\r\n        this._ignoreShadowCaster = sprite;\r\n    }\r\n    /**\r\n     * @type {boolean} Whther or not overlays in shadows should become darker (can create odd artifacts, is very experimental/unfinished)\r\n     */\r\n    set darkenOverlay(bool) {\r\n        this._darkenOverlay = bool;\r\n    }\r\n    /**\r\n     * @type {number} How many pixels of the overlay should be lit up by the light\r\n     */\r\n    set overlayLightLength(length) {\r\n        this._overlayLightLength = length;\r\n    }\r\n\r\n    // Attribute getters\r\n    get range() {\r\n        return this._range;\r\n    }\r\n    get pointCount() {\r\n        return this._pointCount;\r\n    }\r\n    get scatterRange() {\r\n        return this._scatterRange;\r\n    }\r\n    get intensity() {\r\n        return this._intensity;\r\n    }\r\n    get radialResolution() {\r\n        return this._radialResolution;\r\n    }\r\n    get depthResolution() {\r\n        return this._depthResolution;\r\n    }\r\n    get ignoreShadowCaster() {\r\n        return this._ignoreShadowCaster;\r\n    }\r\n    get darkenOverlay() {\r\n        return this._darkenOverlay;\r\n    }\r\n    get overlayLightLength() {\r\n        return this._overlayLightLength;\r\n    }\r\n}\r\n","// Some functions to map a value as a color\nexport const filterFuncs = `\nfloat colorToFloat(vec4 color){\n    return (color.r + (color.g + color.b * 256.0) * 256.0) * 255.0 - 8388608.0;\n}\nvec4 floatToColor(float f){\n    f += 8388608.0;\n    vec4 color;\n    color.a = 255.0;\n    color.b = floor(f / 256.0 / 256.0);\n    color.g = floor((f - color.b * 256.0 * 256.0) / 256.0);\n    color.r = floor(f - color.b * 256.0 * 256.0 - color.g * 256.0);\n    return color / 255.0;\n}\n`;","export default class ShadowFilter extends PIXI.Filter {\r\n    constructor(width, height) {\r\n        super(\r\n            `\r\n            attribute vec2 aVertexPosition;\r\n            attribute vec2 aTextureCoord;\r\n            \r\n            uniform mat3 projectionMatrix;\r\n            uniform mat3 otherMatrix;\r\n            \r\n            varying vec2 vMaskCoord;\r\n            varying vec2 vTextureCoord;\r\n            \r\n            void main(void)\r\n            {\r\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n            \r\n                vTextureCoord = aTextureCoord;\r\n                vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\r\n            }\r\n        `,\r\n            `                    \r\n            varying vec2 vMaskCoord;\r\n            varying vec2 vTextureCoord;\r\n            \r\n            uniform sampler2D uSampler;\r\n            uniform sampler2D mask;\r\n            uniform vec4 maskClamp;\r\n            uniform float ambientLight;\r\n            \r\n            void main(void){            \r\n                vec4 original = texture2D(uSampler, vTextureCoord);\r\n                vec4 masky = texture2D(mask, vMaskCoord);\r\n            \r\n                original *= ambientLight + (1.0 - ambientLight) * (masky.r + masky.g + masky.b) / 3.0;\r\n            \r\n                gl_FragColor = original;\r\n            }\r\n        `\r\n        );\r\n\r\n        this._width = width;\r\n        this._height = height;\r\n        this.tick = 0;\r\n\r\n        this.uniforms.ambientLight = 0.0;\r\n        this.uniforms.size = [this._width, this._height];\r\n        this._useShadowCastersAsOverlay = true;\r\n\r\n        this.__createCasterSources();\r\n        this.__createOverlaySources();\r\n        this.__createMaskSources();\r\n    }\r\n    // Shadow overlay objects\r\n    __createOverlaySources() {\r\n        if (this._shadowOverlayResultTexture)\r\n            this._shadowOverlayResultTexture.destroy();\r\n        if (this._shadowOverlayResultSprite)\r\n            this._shadowOverlayResultSprite.destroy();\r\n\r\n        if (!this._shadowOverlayContainer)\r\n            this._shadowOverlayContainer = new PIXI.Container();\r\n\r\n        // Create the final mask to apply to the container that this filter is applied to\r\n        this._shadowOverlayResultTexture = PIXI.RenderTexture.create(\r\n            this._width,\r\n            this._height\r\n        );\r\n        this._shadowOverlayResultTexture.baseTexture.scaleMode =\r\n            PIXI.SCALE_MODES.NEAREST;\r\n        this._shadowOverlayResultSprite = new PIXI.Sprite(\r\n            this._shadowOverlayResultTexture\r\n        );\r\n    }\r\n    // Shadow caster objects\r\n    __createCasterSources() {\r\n        if (this._shadowCasterResultTexture)\r\n            this._shadowCasterResultTexture.destroy();\r\n        if (this._shadowCasterResultSprite)\r\n            this._shadowCasterResultSprite.destroy();\r\n\r\n        if (!this._shadowCasterContainer)\r\n            this._shadowCasterContainer = new PIXI.Container();\r\n\r\n        // Create the final mask to apply to the container that this filter is applied to\r\n        this._shadowCasterResultTexture = PIXI.RenderTexture.create(\r\n            this._width,\r\n            this._height\r\n        );\r\n        this._shadowCasterResultTexture.baseTexture.scaleMode =\r\n            PIXI.SCALE_MODES.NEAREST;\r\n        this._shadowCasterResultSprite = new PIXI.Sprite(\r\n            this._shadowCasterResultTexture\r\n        );\r\n    }\r\n    // Final mask to apply as a filter\r\n    __createMaskSources() {\r\n        if (this._maskResultTexture) this._maskResultTexture.destroy();\r\n        if (this._maskResultSprite) this._maskResultSprite.destroy();\r\n\r\n        // Create maskMatrix for shader transform data\r\n        if (!this._maskMatrix) this._maskMatrix = new PIXI.Matrix();\r\n\r\n        // Create the final mask to apply to the container that this filter is applied to\r\n        this._maskResultTexture = PIXI.RenderTexture.create(\r\n            this._width,\r\n            this._height\r\n        );\r\n        this._maskResultTexture.baseTexture.scaleMode =\r\n            PIXI.SCALE_MODES.NEAREST;\r\n        if (!this._maskContainer) this._maskContainer = new PIXI.Container();\r\n        this._maskResultSprite = new PIXI.Sprite(this._maskResultTexture);\r\n    }\r\n    // Update the mask texture (called from the Application mixin)\r\n    update(renderer) {\r\n        // Shadows and objects will automatically be added to containers because of the Container mixin\r\n\r\n        this.tick++; // Increase the tick so that shadows and objects know they can add themselves to the container again in their next update\r\n\r\n        /* render shadow casters */\r\n        // Remove the parent layer from the objects in order to properly render it to the container\r\n        this._shadowCasterContainer.children.forEach(child => {\r\n            child._activeParentLayer = null;\r\n        });\r\n\r\n        // Render all the objects onto 1 texture\r\n        renderer.render(\r\n            this._shadowCasterContainer,\r\n            this._shadowCasterResultTexture,\r\n            true,\r\n            null,\r\n            true\r\n        );\r\n\r\n        // Remove all the objects from the container\r\n        this._shadowCasterContainer.children.length = 0;\r\n\r\n        /* render shadow overlays */\r\n        if (!this._useShadowCastersAsOverlay) {\r\n            this._shadowOverlayContainer.children.forEach(child => {\r\n                child._activeParentLayer = null;\r\n            });\r\n\r\n            // Render all the objects onto 1 texture\r\n            renderer.render(\r\n                this._shadowOverlayContainer,\r\n                this._shadowOverlayResultTexture,\r\n                true,\r\n                null,\r\n                true\r\n            );\r\n\r\n            // Remove all the objects from the container\r\n            this._shadowOverlayContainer.children.length = 0;\r\n        }\r\n\r\n        /* render shadows */\r\n\r\n        // Update all shadows and indicate that they may properly be rendered now\r\n        let overlay = this._useShadowCastersAsOverlay\r\n            ? this._shadowCasterResultSprite\r\n            : this._shadowOverlayResultSprite;\r\n        this._maskContainer.children.forEach(shadow => {\r\n            shadow.renderStep = true;\r\n            shadow.update(renderer, this._shadowCasterResultSprite, overlay);\r\n        });\r\n\r\n        // Render all the final shadow masks onto 1 texture\r\n        renderer.render(\r\n            this._maskContainer,\r\n            this._maskResultTexture,\r\n            true,\r\n            null,\r\n            true\r\n        );\r\n\r\n        // Indicate that the shadows may no longer render\r\n        this._maskContainer.children.forEach(shadow => {\r\n            delete shadow.renderStep;\r\n        });\r\n\r\n        // Remove all the shadows from the container\r\n        this._maskContainer.children.length = 0;\r\n    }\r\n\r\n    //  Apply the filter to a container\r\n    apply(filterManager, input, output) {\r\n        // Filter almost directly taken from the pixi mask filter\r\n        const maskSprite = this._maskResultSprite;\r\n        const tex = this._maskResultSprite.texture;\r\n\r\n        if (!tex.valid) {\r\n            return;\r\n        }\r\n        if (!tex.transform) {\r\n            tex.transform = new PIXI.TextureMatrix(tex, 0.0);\r\n        }\r\n\r\n        this.uniforms.mask = tex;\r\n        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(\r\n            this._maskMatrix,\r\n            maskSprite\r\n        );\r\n\r\n        filterManager.applyFilter(this, input, output);\r\n    }\r\n\r\n    // Attribute setters\r\n    /**\r\n     * @type {number} The brightness that unlit areas of the world should have\r\n     */\r\n    set ambientLight(frac) {\r\n        this.uniforms.ambientLight = frac;\r\n    }\r\n    /**\r\n     * @type {number} The width of your application\r\n     */\r\n    set width(width) {\r\n        this._width = width;\r\n\r\n        this.uniforms.size = [this._width, this._height];\r\n        this.__createOverlaySources();\r\n        this.__createCasterSources();\r\n        this.__createMaskSources();\r\n    }\r\n    /**\r\n     * @type {number} The height of your application\r\n     */\r\n    set height(height) {\r\n        this._height = height;\r\n\r\n        this.uniforms.size = [this._width, this._height];\r\n        this.__createOverlaySources();\r\n        this.__createCasterSources();\r\n        this.__createMaskSources();\r\n    }\r\n    /**\r\n     * @type {boolean} Whether or not to use shadow casters as shadow overlays as well\r\n     */\r\n    set useShadowCasterAsOverlay(val) {\r\n        this._useShadowCastersAsOverlay = val;\r\n    }\r\n\r\n    // Attribute getters\r\n    get ambientLight() {\r\n        return this.uniforms.ambientLight;\r\n    }\r\n    get width() {\r\n        return this._width;\r\n    }\r\n    get height() {\r\n        return this._height;\r\n    }\r\n    get useShadowCasterAsOverlay() {\r\n        return this._useShadowCastersAsOverlay;\r\n    }\r\n}\r\n","import { filterFuncs } from \"./FilterFuncs\";\r\n\r\nlet maxDepthResolution = \"2000.0\";\r\nexport default class ShadowMapFilter extends PIXI.Filter {\r\n    constructor(shadow) {\r\n        super(\r\n            `\r\n            attribute vec2 aVertexPosition;\r\n            attribute vec2 aTextureCoord;\r\n            \r\n            uniform mat3 projectionMatrix;\r\n            uniform mat3 filterMatrix;\r\n            \r\n            varying vec2 vTextureCoord;\r\n            varying vec2 vFilterCoord;\r\n            \r\n            void main(void){\r\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n                vTextureCoord = aTextureCoord;\r\n            }\r\n        `,\r\n            `\r\n            varying vec2 vMaskCoord;\r\n            varying vec2 vTextureCoord;\r\n            uniform vec4 filterArea;\r\n            \r\n            uniform sampler2D shadowCasterSampler;\r\n            uniform vec2 shadowCasterSpriteDimensions;\r\n\r\n            uniform bool hasIgnoreShadowCaster;\r\n            uniform sampler2D ignoreShadowCasterSampler;\r\n            uniform mat3 ignoreShadowCasterMatrix;\r\n            uniform vec2 ignoreShadowCasterDimensions;\r\n\r\n            uniform float lightRange;\r\n            uniform float lightScatterRange;\r\n            uniform vec2 lightLoc;\r\n\r\n            uniform float depthResolution;\r\n            uniform bool darkenOverlay;\r\n\r\n            uniform vec2 dimensions;\r\n\r\n            ${filterFuncs}\r\n            \r\n            void main(void){\r\n                float pi = 3.141592653589793238462643;\r\n                \r\n                // Cap the depthResolution (as I expect performance loss by having a big value, but I am not sure)\r\n                float depthRes = min(${maxDepthResolution}, depthResolution);\r\n\r\n                // The current coordinate on the texutre measured in pixels, as well as a fraction\r\n                vec2 pixelCoord = vTextureCoord * filterArea.xy;\r\n                vec2 normalizedCoord = pixelCoord / dimensions;\r\n                \r\n                // Extract the components of the normalized coordinate\r\n                float x = normalizedCoord.x;\r\n                float y = normalizedCoord.y;\r\n\r\n                // Calculate the offset of the lightPoint we are currently at\r\n                float offsetAngle = 2.0 * pi * y;\r\n                vec2 offset = vec2(cos(offsetAngle), sin(offsetAngle)) * lightScatterRange;\r\n\r\n                // Calculate the angle at which we are ray tracing\r\n                float angle = x * pi * 2.0;\r\n\r\n                // The distance at which we hit an object\r\n                float hitDistancePer = 1.0;\r\n\r\n                // Increase the distance until we hit an object or reach the maximum value\r\n                bool reached = false;\r\n                for(float dist=0.0; dist < ${maxDepthResolution}; dist+=1.0){\r\n                    if(dist > depthRes) break;\r\n                    \r\n                    // Calculate the actual distance in pixel units, and use it to calculate the pixel coordinate to inspect\r\n                    float distance = dist / depthRes * lightRange;\r\n                    vec2 coord = lightLoc + offset + vec2(cos(angle), sin(angle)) * distance;\r\n                \r\n                    // Extract the pixel and check if it is opaque\r\n                    float opacity = texture2D(shadowCasterSampler, coord / shadowCasterSpriteDimensions).a;\r\n                    if((opacity > 0.0 && darkenOverlay) || opacity > 0.5){\r\n                        // Check if it isn't hitting something that should be ignore\r\n                        if(hasIgnoreShadowCaster){ \r\n                            vec2 l = (ignoreShadowCasterMatrix * vec3(coord, 1.0)).xy / ignoreShadowCasterDimensions;\r\n                            if(l.x >= -0.01 && l.x <= 1.01 && l.y >= -0.01 && l.y <= 1.01){\r\n                                // If the pixel at the ignoreShadowCaster is opaque here, skip this pixel\r\n                                if(opacity > 0.0){\r\n                                    continue;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Calculate the percentage at which this hit occurred, and stop the loop\r\n                        if(!darkenOverlay){\r\n                            hitDistancePer = distance / lightRange;\r\n                            break;\r\n                        }\r\n                        reached = true;\r\n                    }else if(reached){\r\n                        hitDistancePer = (distance - 1.0) / lightRange;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // Express the distance as a color in the map\r\n                gl_FragColor = floatToColor(hitDistancePer * 100000.0);\r\n            }\r\n        `\r\n        );\r\n\r\n        this.uniforms.lightPointCount = shadow.pointCount;\r\n\r\n        this.uniforms.dimensions = [shadow.radialResolution, shadow.pointCount];\r\n        this.shadow = shadow;\r\n\r\n        this.autoFit = false;\r\n        this.padding = 0;\r\n\r\n        this.ignoreShadowCasterMatrix = new PIXI.Matrix();\r\n    }\r\n\r\n    apply(filterManager, input, output) {\r\n        // Decide whether or not to darken the overlays\r\n        this.uniforms.darkenOverlay = this.shadow._darkenOverlay;\r\n\r\n        // Attach the object sampler\r\n        var sc = this.shadow._shadowCasterSprite;\r\n        this.uniforms.shadowCasterSpriteDimensions = [sc.width, sc.height];\r\n        this.uniforms.shadowCasterSampler = sc._texture;\r\n\r\n        // Use the world transform (data about the absolute location on the screen) to determine the lights relation to the objectSampler\r\n        var wt = this.shadow.worldTransform;\r\n        var scale = Math.sqrt(wt.a * wt.a + wt.b * wt.b);\r\n        var range = this.shadow.range * scale;\r\n        this.uniforms.lightRange = range;\r\n        this.uniforms.lightScatterRange = this.shadow.scatterRange;\r\n        this.uniforms.lightLoc = [wt.tx, wt.ty];\r\n        this.uniforms.depthResolution = range * this.shadow.depthResolution;\r\n\r\n        // Check if there is an object that the filter should attempt to ignore\r\n        var isc = this.shadow.ignoreShadowCaster;\r\n        this.uniforms.hasIgnoreShadowCaster = !!isc;\r\n        if (isc) {\r\n            // Calculate the tranform matrix in order to access the proper pixel of the ignoreObject\r\n            isc.worldTransform.copy(this.ignoreShadowCasterMatrix);\r\n            this.uniforms.ignoreShadowCasterMatrix = this.ignoreShadowCasterMatrix.invert();\r\n\r\n            // Attach the ignore object\r\n            this.uniforms.ignoreShadowCasterDimensions = [\r\n                isc.width,\r\n                isc.height\r\n            ];\r\n            this.uniforms.ignoreShadowCasterSampler = isc._texture;\r\n        }\r\n\r\n        // Apply the filter\r\n        filterManager.applyFilter(this, input, output);\r\n    }\r\n}\r\n","import { filterFuncs } from \"./FilterFuncs\";\r\nexport default class ShadowMaskFilter extends PIXI.Filter {\r\n    constructor(shadow) {\r\n        super(\r\n            `\r\n            attribute vec2 aVertexPosition;\r\n            attribute vec2 aTextureCoord;\r\n            \r\n            uniform mat3 projectionMatrix;\r\n            uniform mat3 overlayMatrix;\r\n            uniform mat3 filterMatrix;\r\n            \r\n            varying vec2 vTextureCoord;\r\n            varying vec2 vOverlayCoord;\r\n            varying vec2 vFilterCoord;\r\n            \r\n            void main(void){\r\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n                vTextureCoord = aTextureCoord;\r\n                vOverlayCoord = (overlayMatrix * vec3(aTextureCoord, 1.0) ).xy;\r\n            }\r\n        `,\r\n            `\r\n            varying vec2 vOverlayCoord;\r\n            varying vec2 vTextureCoord;\r\n            uniform vec4 filterArea;\r\n            \r\n            uniform sampler2D shadowOverlaySampler;\r\n\r\n            uniform vec2 dimensions;\r\n\r\n            uniform sampler2D shadowSampler;\r\n\r\n            uniform bool darkenOverlay;\r\n            uniform bool inverted;\r\n\r\n            uniform float overlayLightLength;\r\n\r\n            uniform float lightPointCount;\r\n            uniform float lightRange;\r\n            uniform float lightScatterRange;\r\n            uniform float lightIntensity;\r\n\r\n            ${filterFuncs}\r\n            \r\n            void main(void){\r\n                float pi = 3.141592653589793238462643;\r\n                \r\n                // The current coordinate on the texture measured in pixels\r\n                vec2 pixelCoord = vTextureCoord * filterArea.xy;\r\n\r\n                // The distance delta relative to the center\r\n                vec2 lightDelta = pixelCoord - dimensions / 2.0;\r\n                float distance = sqrt(lightDelta.x * lightDelta.x + lightDelta.y * lightDelta.y);\r\n                if (distance > lightRange) return;\r\n\r\n                // The final intensity of the light at this pixel\r\n                float totalIntensity = 0.0;\r\n\r\n                // The intensity of the pixel in the overlay map at this pixel\r\n                vec4 overlayPixel = texture2D(shadowOverlaySampler, vOverlayCoord);\r\n\r\n                // Go through all light points (at most 1000) to add them to the intensity\r\n                for(float lightIndex=0.0; lightIndex<1000.0; lightIndex++){\r\n                    if (lightIndex >= lightPointCount) break; // Stop the loop if we went over the pointCount\r\n\r\n                    // Calculate the offset of this lightPoint, relative the the center of the light\r\n                    float lightIndexFrac = (lightIndex + 0.5) / lightPointCount;\r\n                    float offsetAngle = 2.0 * pi * lightIndexFrac;\r\n                    vec2 offset = vec2(cos(offsetAngle), sin(offsetAngle)) * lightScatterRange;\r\n\r\n                    // Calculate the location of this pixel relative to the lightPoint, and check the depth map\r\n                    vec2 pointDelta = lightDelta - offset;\r\n                    float pointDistance = sqrt(pointDelta.x * pointDelta.x + pointDelta.y * pointDelta.y);\r\n                    float angle = mod(atan(pointDelta.y, pointDelta.x) + 2.0 * pi, 2.0 * pi);\r\n                    vec4 depthPixel = texture2D(shadowSampler, vec2(angle / (2.0 * pi), lightIndexFrac));\r\n\r\n                    // Extract the object distance from the depth map pixel\r\n                    float objectDistance = colorToFloat(depthPixel) / 100000.0 * lightRange;\r\n                    \r\n                    // Calculate the intensity of this pixel based on the overlaySampler and objectDistance\r\n                    float intensity = 0.0;\r\n                    if(darkenOverlay){\r\n                        if(objectDistance > pointDistance || objectDistance >= lightRange){\r\n                            intensity = 1.0 - distance / lightRange;\r\n                        }else if(overlayPixel.a > 0.5){\r\n                            intensity = 1.0 - distance / lightRange;\r\n                            intensity *= pow(1.0 - (distance - objectDistance) / (lightRange - objectDistance), 2.5) * overlayPixel.a;\r\n                        }\r\n                    }else{\r\n                        if(inverted){\r\n                            if(overlayPixel.a > 0.5){\r\n                                intensity = 1.0-overlayPixel.a;\r\n                            }else if (objectDistance > pointDistance || objectDistance >= lightRange) {\r\n                                intensity = 0.0;\r\n                            }else{\r\n                                intensity = 1.0;\r\n                            }\r\n                        }else{\r\n                            if (objectDistance > pointDistance || objectDistance >= lightRange) {\r\n                                intensity = 1.0 - distance / lightRange;\r\n                            }else if (overlayPixel.a > 0.5) {\r\n                                intensity = (1.0 - distance / lightRange) * max(0.0, min(1.0, (1.0 - (pointDistance - objectDistance) / overlayLightLength)));\r\n                            }\r\n                        }\r\n                    }\r\n                    \r\n\r\n                    // Add the intensity to the total intensity\r\n                    totalIntensity += intensity / lightPointCount;\r\n                }\r\n\r\n                // Create a mask based on the intensity\r\n                gl_FragColor = vec4(vec3(lightIntensity * totalIntensity), 1.0);\r\n            }\r\n        `\r\n        );\r\n\r\n        this.uniforms.shadowSampler = shadow._shadowMapResultTexture;\r\n        this.uniforms.lightPointCount = shadow._pointCount;\r\n\r\n        this.shadow = shadow;\r\n        this._inverted = false;\r\n\r\n        this.autoFit = false;\r\n        this.padding = 0;\r\n        this.overlayMatrix = new PIXI.Matrix();\r\n    }\r\n\r\n    apply(filterManager, input, output) {\r\n        // Decide whether or not to darken the overlays\r\n        this.uniforms.darkenOverlay = this.shadow._darkenOverlay;\r\n\r\n        // Attach the object sampler\r\n        var sc = this.shadow._shadowOverlaySprite;\r\n        this.uniforms.shadowOverlaySpriteDimensions = [sc.width, sc.height];\r\n        this.uniforms.shadowOverlaySampler = sc._texture;\r\n\r\n        // Use the world transform (data about the absolute location on the screen) to determine the lights relation to the objectSampler\r\n        var wt = this.shadow.worldTransform;\r\n        var scale = Math.sqrt(wt.a * wt.a + wt.b * wt.b);\r\n        var range = this.shadow.range * scale;\r\n        this.uniforms.lightRange = range;\r\n        this.uniforms.lightScatterRange = this.shadow.scatterRange;\r\n        this.uniforms.lightIntensity = this.shadow.intensity;\r\n\r\n        // The length of the area of the overlay to be lit\r\n        this.uniforms.overlayLightLength = this.shadow.overlayLightLength;\r\n\r\n        // Invert the filter if specified\r\n        this.uniforms.inverted = this._inverted;\r\n\r\n        // Texture size increase in order to fit the sprite rectangle (even though we are only interested in a circle)\r\n        // So we have to consider this in the texture size\r\n        var texWidth = this.shadow.range * Math.abs(wt.a + wt.b) * 2;\r\n        var texHeight = this.shadow.range * Math.abs(wt.d - wt.c) * 2;\r\n        this.uniforms.dimensions = [texWidth, texHeight];\r\n\r\n        // Calculate the object sampler position in relation to the light\r\n        this.uniforms.overlayMatrix = filterManager.calculateSpriteMatrix(\r\n            this.overlayMatrix,\r\n            sc\r\n        );\r\n\r\n        // Apply the filter\r\n        filterManager.applyFilter(this, input, output);\r\n    }\r\n}\r\n","import ContainerSetup from './mixins/Container';\r\nimport ApplicationSetup from './mixins/Application';\r\nimport ShadowFilter from './filters/ShadowFilter';\r\nimport ShadowMapFilter from './filters/ShadowMapFilter';\r\nimport ShadowMaskFilter from './filters/ShadowMaskFilter';\r\nimport FilterFuncs from './filters/FilterFuncs';\r\nimport Shadow from './Shadow';\r\n\r\nPIXI.shadows = {\r\n    init: function(application){\r\n        // The objects that will cast shadows\r\n        this.casterGroup = new PIXI.display.Group();\r\n        this.casterLayer = new PIXI.display.Layer(this.casterGroup);\r\n\r\n        // The objects that will remain ontop of the shadows\r\n        this.overlayGroup = new PIXI.display.Group();\r\n        this.overlayLayer = new PIXI.display.Layer(this.overlayGroup);\r\n\r\n        // Make sure the caster objects aren't actually visible\r\n        this.casterLayer.renderWebGL = function(){}; \r\n        this.overlayLayer.renderWebGL = function(){}; \r\n\r\n        // Create the shadow filter\r\n        this.filter = new ShadowFilter(application.renderer.width, application.renderer.height);\r\n\r\n        // Set up the container mixin so that it tells the filter about the available shadows and objects\r\n        ContainerSetup(this.casterGroup, this.overlayGroup, this.filter);\r\n\r\n        // Overwrite the application render method\r\n        ApplicationSetup(application, this.filter);\r\n\r\n        // If a container is specified, set up the filter\r\n        var container = new PIXI.Container();\r\n        application.stage.addChild(container);\r\n\r\n        // Set up the shadow layers\r\n        application.stage.addChild(\r\n            this.casterLayer,\r\n            this.overlayLayer\r\n        );\r\n\r\n        // Set up pixi lights if available\r\n        if(PIXI.lights){\r\n            // Set up pixi-light's layers\r\n            this.diffuseLayer = new PIXI.display.Layer(PIXI.lights.diffuseGroup);\r\n            this.normalLayer = new PIXI.display.Layer(PIXI.lights.normalGroup);\r\n            this.lightLayer = new PIXI.display.Layer(PIXI.lights.lightGroup);\r\n            var diffuseBlackSprite = new PIXI.Sprite(this.diffuseLayer.getRenderTexture());\r\n            diffuseBlackSprite.tint = 0;\r\n            \r\n            application.stage.addChild(\r\n                this.diffuseLayer,\r\n                diffuseBlackSprite,\r\n                this.normalLayer,\r\n                this.lightLayer\r\n            );\r\n\r\n            // Add the shadow filter to the diffuse layer\r\n            this.diffuseLayer.filters = [this.filter];\r\n        }else{\r\n\r\n            // Add the shadow filter to the container\r\n            container.filters = [this.filter];\r\n        }\r\n\r\n        // Rreturn the container to use\r\n        return container;\r\n    },\r\n    Shadow,\r\n\r\n    // Making all classes available for if you want to augmnent this code without going into the source and properly building things afterwards\r\n    __classes: {\r\n        ContainerSetup,\r\n        ApplicationSetup,\r\n        ShadowFilter,\r\n        ShadowMapFilter,\r\n        ShadowMaskFilter,\r\n        FilterFuncs,\r\n        Shadow,\r\n    }\r\n};\r\nexport default PIXI.shadows;","export default function augment(application, shadowFilter){\r\n    // Replace the stage with a layered stage\r\n    application.stage = new PIXI.display.Stage();\r\n\r\n    // Remove the current render fucntion\r\n    application.ticker.remove(application.render, application); \r\n\r\n    // Overwrite the render function\r\n    application.render = function(){\r\n        // Update stage transforms\r\n        const cacheParent = this.stage.parent;\r\n        this.stage.parent = this.renderer._tempDisplayObjectParent;\r\n        this.stage.updateTransform();\r\n        this.stage.parent = cacheParent;\r\n    \r\n        // Update the shadow filter\r\n        shadowFilter.update(this.renderer);\r\n    \r\n        // Render the stage without updating the transforms again\r\n        this.renderer.render(this.stage, undefined, undefined, undefined, true);\r\n    }\r\n\r\n    // Reassign ticker because its setter initialises the render method\r\n    application.ticker = application.ticker;\r\n}","import Shadow from '../Shadow';\r\nexport default function setup(shadowCasterGroup, shadowOverlayGroup, shadowFilter){\r\n    const orTransform = PIXI.Container.prototype.updateTransform;\r\n    PIXI.Container.prototype.updateTransform = function(){\r\n\r\n        if(this.parentGroup == shadowCasterGroup){\r\n            if(this.tick != shadowFilter.tick)\r\n                shadowFilter._shadowCasterContainer.children.push(this);\r\n            this.tick = shadowFilter.tick;\r\n        }\r\n\r\n        if(this.parentGroup == shadowOverlayGroup){\r\n            if(this.tick != shadowFilter.tick)\r\n                shadowFilter._shadowOverlayContainer.children.push(this);\r\n            this.tick = shadowFilter.tick;\r\n        }\r\n    \r\n        if(this instanceof Shadow){\r\n            if(this.tick != shadowFilter.tick)\r\n                shadowFilter._maskContainer.children.push(this);\r\n            this.tick = shadowFilter.tick;\r\n        }\r\n    \r\n        return orTransform.apply(this, arguments);\r\n    };\r\n}"],"sourceRoot":""}